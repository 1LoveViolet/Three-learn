<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>three.js app</title>
    <style>
      body {
        margin: 0;
        position: relative;
      }
      #tooltip {
        position: absolute;
        left: 0;
        top: 0;
        padding: 6px;
        border-radius: 4px;
        display: none;
        background: #fff;
        /* 解决当鼠标移动到tooltip元素上时候停顿的问题 */
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="tooltip"></div>
    <script src="./dat.gui/build/dat.gui.min.js"></script>
    <script src="./stats.js/build/stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/gsap.min.js"></script>
    <script src="./js/axios.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      // 现在浏览器支持ES6语法，自然包括import方式引入js文件
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
      const gui = new dat.GUI();
      var renderer, scene, camera, controls;
      // 初始化场景
      function initScene() {
        scene = new THREE.Scene();
        //给场景添加烟雾效果
        // 参数：烟雾颜色，烟雾范围near，烟雾范围far
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x000000, 0, 3000);
        // 给场景添加坐标轴
        var axes = new THREE.AxesHelper(100);
        scene.add(axes);
      }
      // 初始化渲染器
      function initRenderer() {
        // antialias是否开启抗锯齿
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xeeeeee);
        renderer.physicallyCorrectLights = true;
        document.body.appendChild(renderer.domElement);
      }
      // 初始化相机
      let v = new THREE.Vector3(32.499207496643066, 38.21255111694336, 0);
      function initCamera() {
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        // camera.position.y = 0;
        camera.position.set(32.499207496643066, 38.21255111694336, 10);
        camera.lookAt(v);

        // camera.position.z = 220;
      }
      // 初始化控制器
      function initControls() {
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(32.499207496643066, 38.21255111694336, 0);
        // 阻尼效果
        controls.enableDamping = true;
        // 摄像机自动旋转
        controls.autoRotate = false;
        // 控制垂直角度的旋转范围
        // controls;
      }
      var pointLight;
      // 初始化光源
      function initLight() {
        // 白光，光强1
        pointLight = new THREE.PointLight(0xffffff, 10000);
        pointLight.position.set(0, 50, 50);
        scene.add(pointLight);
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1);
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight2.position.set(0, -1, 0);
        scene.add(directionalLight1);
        scene.add(directionalLight2);
      }
      var stats = new Stats();
      document.body.appendChild(stats.dom);

      function render() {
        raycaster.setFromCamera(mouse, camera);
        const mapChildren = scene.children.filter(
          (item) => item.type === "Mesh"
        );
        // 被射线照射到的一组对象
        const intersects = raycaster.intersectObjects(mapChildren);
        const tooltip = document.getElementById("tooltip");
        // 如果有相交的物体
        if (intersects.length > 0) {
          //   console.log(intersects);
          tooltip.style.display = "block";
          tooltip.style.left = mouseX + "px";
          tooltip.style.top = mouseY + "px";
          tooltip.innerText = intersects[0].object.name;
          if (INTERSECTED != intersects[0].object) {
            // 这里选中的物体是上一个选中物体。
            if (INTERSECTED) {
              // 把上一个选中的物体设置为当前色。
              INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            }
            // 设置当前选中的物体
            INTERSECTED = intersects[0].object;
            // 保留当前选中物体，**原本的颜色**
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
            // console.log(INTERSECTED.currentHex);
            // 设置当前选中的物体颜色为红色
            INTERSECTED.material.color.setHex(0xff0000);
          }
          // 如果没有相交的物体，把选中的物体设置为原来的颜色
        } else {
          if (INTERSECTED) {
            INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
          }
          // 清空选中物体
          tooltip.style.display = "none";
          INTERSECTED = null;
        }
        renderer.render(scene, camera);
        controls.update();
        stats.update(); //更新性能插件
        requestAnimationFrame(render);
      }

      function cube() {
        const geometry = new THREE.SphereGeometry(1, 32, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(32.499207496643066, 38.21255111694336, 0);
        scene.add(sphere);
        console.log(sphere);
      }
      // 用于计算整个图形的中心位置
      const mapSideInfo = {
        minlon: Infinity,
        maxlon: -Infinity,
        minlat: Infinity,
        maxlat: -Infinity,
      };

      // 中心坐标，用于到时候将图形绘制到坐标系原点计算使用
      let centerPos = {};
      let merTrans;
      var geoJson;
      var meshArr = [],
        lineArr = [];

      const getGeoJson = async (adcode, isFull = true) => {
        axios({
          url: `https://geo.datav.aliyun.com/areas_v3/bound/geojson?code=${adcode}${
            isFull ? "_full" : ""
          }`,
          method: "get",
        })
          .then(function (response) {
            if (meshArr.length !== 0 && lineArr.length !== 0) {
              scene.remove(...meshArr);
              scene.remove(...lineArr);
              console.log("meshArr和lineArr都不为空");
            }
            // console.log(response.data);
            geoJson = response.data;
            calcSide(geoJson);
            meshArr = drawMap(geoJson);
            lineArr = drawLine(geoJson);
            // console.log(...meshArr);
            console.log(meshArr[0]);
            // scene.add(...meshArr);
            scene.add(...meshArr);
            scene.add(...lineArr);
            cube();
            // mousemove();
            console.log(scene);
          })
          .catch(function (err) {
            console.log(err);
          });
      };
      getGeoJson(100000);

      //包装一个根据geoJson格式数据获取经纬度坐标集合的方法
      const dealWithCoord = (geometry, callback) => {
        const { type, coordinates } = geometry;

        // 多面处理
        if (type === "MultiPolygon") {
          coordinates.forEach((polyArray) => {
            polyArray.forEach((lonlatArr) => {
              callback(lonlatArr);
            });
          });
        } else
          coordinates.forEach((lonlatArr) => {
            callback(lonlatArr);
          });
      };

      //包装获取最大最小经纬度信息以及中心点坐标信息的方法，传递的参数就是获取到的geoJson数据
      const calcSide = (geoJson) => {
        const { features } = geoJson;

        features.forEach((feature) => {
          dealWithCoord(feature.geometry, (lonlatArr) => {
            lonlatArr.forEach(([lon, lat]) => {
              if (lon > mapSideInfo.maxlon) mapSideInfo.maxlon = lon;
              if (lon < mapSideInfo.minlon) mapSideInfo.minlon = lon;
              if (lat > mapSideInfo.maxlat) mapSideInfo.maxlat = lat;
              if (lat < mapSideInfo.minlat) mapSideInfo.minlat = lat;
            });
          });
        });

        centerPos = {
          x: (mapSideInfo.maxlon + mapSideInfo.minlon) / 2,
          y: (mapSideInfo.maxlat + mapSideInfo.minlat) / 2,
        };
        // console.log([centerPos.x, centerPos.y]);
        merTrans = d3
          .geoMercator()
          .center([centerPos.x, centerPos.y])
          .translate([0, 0]);
        // console.log(merTrans);
      };

      const drawPlan = (lonlatArr) => {
        // 可以理解为canvas的绘制形状，moveTo、lineTo
        const shap = new THREE.Shape();
        lonlatArr.forEach((lonlat, index) => {
          const [x, y] = merTrans(lonlat);
          if (!index) shap.moveTo(x, y);
          else shap.lineTo(x, y);
        });
        return shap;
      };
      const drawPoint = (lonlatArr) => {
        const pointsArray = new Array();
        lonlatArr.forEach((lonlat) => {
          const [x, y] = merTrans(lonlat);
          // 创建三维点
          pointsArray.push(new THREE.Vector3(x, -y, 0.2));
        });
        return pointsArray;
      };
      const addmesh = (lonlatArr) => {
        // console.log(lonlatArr);
        const shap = drawPlan(lonlatArr);
        // 几何体
        const geo = new THREE.ExtrudeGeometry(shap, extrudeSettings);
        geo.rotateX(Math.PI);
        // 材质
        const material = new THREE.MeshStandardMaterial({
          color: randomColor(),
          //   color: "#0000ff",
        });
        material.backup = material.color.getHex();
        // 物体
        const mesh = new THREE.Mesh(geo, material);
        return mesh;
      };
      const addLine = (lonlatArr) => {
        const lineGeometry = new THREE.BufferGeometry();
        const pointsArray = drawPoint(lonlatArr);
        lineGeometry.setFromPoints(pointsArray);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: "#000000",
        });
        let line = new THREE.Line(lineGeometry, lineMaterial);
        return line;
      };
      const randomColor = () =>
        `rgb(${Math.floor(Math.random() * 255)},${Math.floor(
          Math.random() * 255
        )},${Math.floor(Math.random() * 255)})`;

      const extrudeSettings = {
        steps: 10, //用于沿着挤出样条的深度细分的点的数量，默认值为1。
        depth: 8, //挤出的形状的深度，默认值为1。
        bevelEnabled: true, //对挤出的形状应用是否斜角，默认值为true。
        bevelThickness: 0.2, //设置原始形状上斜角的厚度。默认值为0.2。
        bevelSize: 0.1, //斜角与原始形状轮廓之间的延伸距离
        bevelOffset: 0,
        bevelSegments: 3, //斜角的分段层数
      };
      const drawMap = (geoJson) => {
        console.log(geoJson);
        const meshArray = [];
        const { features } = geoJson;
        features.forEach((feature) => {
          dealWithCoord(feature.geometry, (lonlatArr) => {
            let mesh = addmesh(lonlatArr);
            mesh.name = feature.properties.name;
            meshArray.push(mesh);
          });
        });
        return meshArray;
      };
      const drawLine = (geoJson) => {
        const lineArray = [];
        const { features } = geoJson;
        features.forEach((feature) => {
          dealWithCoord(feature.geometry, (lonlatArr) => {
            let line = addLine(lonlatArr);
            // line.position.set(0, 9, 0);
            lineArray.push(line);
          });
        });
        return lineArray;
      };

      var mouse, mouseX, mouseY, raycaster, INTERSECTED;
      mouse = new THREE.Vector2();
      const getSelMap = () => {
        const mapChildren = scene.children;
        raycaster = new THREE.Raycaster();
        const sizes = {
          width: window.innerWidth,
          height: window.innerHeight,
        };
        mouse = new THREE.Vector2();
        window.addEventListener("mousemove", (_event) => {
          mouse.x = (_event.clientX / sizes.width) * 2 - 1;
          mouse.y = -(_event.clientY / sizes.height) * 2 + 1;
          mouseX = _event.clientX;
          mouseY = _event.clientY;
        });
      };

      function addGui() {
        gui
          .add(extrudeSettings, "steps")
          .min(2)
          .max(10)
          .step(1)
          .name("steps")
          .onFinishChange(getGeoJson);
        gui
          .add(extrudeSettings, "depth")
          .min(2)
          .max(16)
          .step(1)
          .name("depth")
          .onFinishChange(getGeoJson);
        gui
          .add(pointLight, "intensity")
          .min(5000)
          .max(50000)
          .step(10)
          .name("intensity");
        //   .onFinishChange(getGeoJson);
      }

      function start() {
        initRenderer();
        initScene();
        initCamera();
        initControls();
        initLight();
        addGui();
        getSelMap();
        // mousemove();
        render();
      }
      start();
    </script>
  </body>
</html>
