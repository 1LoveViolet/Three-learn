<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>three.js app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script src="./dat.gui/build/dat.gui.min.js"></script>
    <script src="./stats.js/build/stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/gsap.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      // 现在浏览器支持ES6语法，自然包括import方式引入js文件
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      const gui = new dat.GUI();
      var renderer, scene, camera, controls;
      // 初始化场景
      function initScene() {
        scene = new THREE.Scene();
        //给场景添加烟雾效果
        // 参数：烟雾颜色，烟雾范围near，烟雾范围far
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x000000, 0, 3000);
        // 给场景添加坐标轴
        // var axes = new THREE.AxesHelper(100);
        // scene.add(axes);
      }
      // 初始化渲染器
      function initRenderer() {
        // antialias是否开启抗锯齿
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x160016, 1);
        document.body.appendChild(renderer.domElement);
      }
      // 初始化相机
      function initCamera() {
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.x = 50;
        camera.position.y = 50;
        camera.position.z = 50;
      }
      // 初始化控制器
      function initControls() {
        controls = new OrbitControls(camera, renderer.domElement);
        // 阻尼效果
        controls.enableDamping = true;
        // 摄像机自动旋转
        controls.autoRotate = false;
        // 控制垂直角度的旋转范围
        controls;
      }
      // 初始化光源
      function initLight() {
        // 白光，光强1
        var pointLight = new THREE.PointLight(0xffffff, 10000);
        pointLight.position.set(0, 100, 100);
        scene.add(pointLight);
      }
      var stats = new Stats();
      document.body.appendChild(stats.dom);
      const vertexShader = /* GLSL */ `
  uniform float uTime;
  varying vec2 vUv;
  attribute float aSize;
  attribute vec4 aShift;
  varying vec3 vColor;

  const float PI = 3.141592653589793238;

  void main() {
    vUv = uv;
    vec3 color1 = vec3(227., 155., 0.);
    vec3 color2 = vec3(100., 50., 255.);
    // float d = fract(length(abs(position) / vec3(40., 10., 40.))*1000.0);
    float d = length(abs(position) / vec3(40., 10., 40.));
    d = clamp(d, 0., 1.);
    vColor = mix(color1, color2, d) / 255.0;

    vec3 transformed = position;
  float theta = mod(aShift.x + aShift.z * uTime, PI * 2.);
  float phi = mod(aShift.y + aShift.z * uTime, PI * 2.);
  transformed += vec3(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta)) * aShift.w;


    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
    gl_PointSize = 50.0 / -mvPosition.z*aSize;
    gl_Position = projectionMatrix * mvPosition;

  }
`;

      const fragmentShader = /* GLSL */ `
  varying vec2 vUv;
  varying vec3 vColor;

  void main() {
  //   float mask = step(length(gl_PointCoord - 0.5),0.5);
  // if(mask < 0.5) discard;
  // gl_FragColor = vec4(vColor, 1.0);

  float d = length(gl_PointCoord - 0.5);
  if (d > 0.5) discard;
  gl_FragColor = vec4(vColor, smoothstep(1.0, 0.1, d));
  }
`;

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
      });

      //   const material2 = new THREE.PointsMaterial({
      //     size: 0.4,
      //     color: 0xffffff,
      //   });
      //   const geometry = new THREE.SphereGeometry(10);
      // const geometry = new THREE.IcosahedronGeometry(10, 6);
      //   const mesh = new THREE.Mesh(geometry, material);

      const count1 = 50000;
      const count2 = 100000;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const sizes = [];
      const shifts = [];
      for (let i = 0; i < count1 + count2; i++) {
        let theta = Math.random() * Math.PI * 2;
        // let phi = Math.random() * Math.PI; // 两极密集
        let phi = Math.acos(Math.random() * 2 - 1); // 分布更均匀
        let size = Math.random() * 1.5 + 0.5; // 0.5-2.0
        let angle = (Math.random() * 0.9 + 0.1) * Math.PI * 0.1;
        let strength = Math.random() * 0.9 + 0.1; // 0.1-1
        shifts.push(theta, phi, angle, strength);

        sizes.push(size);
        if (i < count1) {
          // let r = 10;
          let r = Math.random() * 0.5 + 9.5;
          // let x = r * Math.sin(phi) * Math.cos(theta);
          // let y = r * Math.cos(phi);
          // let z = r * Math.sin(phi) * Math.sin(theta);
          let { x, y, z } = new THREE.Vector3()
            .randomDirection()
            .multiplyScalar(r);
          positions.push(x, y, z);
        } else {
          // 圆盘/圆柱部分
          let r = 10;
          let R = 40;
          let rand = Math.pow(Math.random(), 1.5);
          let radius = Math.sqrt(R * R * rand + (1 - rand) * r * r);
          let { x, y, z } = new THREE.Vector3().setFromCylindricalCoords(
            radius,
            Math.random() * 2 * Math.PI,
            (Math.random() - 0.5) * 2
          );
          positions.push(x, y, z);
        }
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3)
      );
      geometry.setAttribute(
        "aSize",
        new THREE.Float32BufferAttribute(sizes, 1)
      );
      geometry.setAttribute(
        "aShift",
        new THREE.Float32BufferAttribute(shifts, 4)
      );

      const points = new THREE.Points(geometry, material);
      //   const points = new THREE.Points(geometry, material2);

      const clock = new THREE.Clock();
      function render() {
        // 触底弹跳
        // circle.position.y = Math.abs(Math.sin(elapsedTime * 3));
        const time = clock.getElapsedTime();
        points.rotation.y = time * 0.01;
        material.uniforms.uTime.value = time;
        // mesh.rotation.y = time;
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        controls.update();
        stats.update(); //更新性能插件
      }

      function start() {
        initRenderer();
        initScene();
        initCamera();
        initControls();
        initLight();
        render();
      }
      start();

      //   scene.add(mesh);
      points.rotation.order = "ZYX";
      points.rotation.z = 0.2;
      scene.add(points);
    </script>
  </body>
</html>
