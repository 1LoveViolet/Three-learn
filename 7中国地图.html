<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>three.js app</title>
    <style>
      body {
        margin: 0;
        position: relative;
        /* background: url("./img/mapback.png") center no-repeat;
        background-size: cover; */
      }
      #tooltip {
        position: absolute;
        left: 0;
        top: 0;
        padding: 6px;
        border-radius: 4px;
        display: none;
        background: #fff;
        /* 解决当鼠标移动到tooltip元素上时候停顿的问题 */
        pointer-events: none;
      }
      /* .box {
        width: 100px;
        height: 100px;
        position: absolute;
        top: 100px;
        left: 100px;
        background-color: aqua;
      } */
    </style>
  </head>
  <body>
    <div id="tooltip"></div>
    <!-- <div class="box">123</div> -->
    <script src="./dat.gui/build/dat.gui.min.js"></script>
    <script src="./stats.js/build/stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/gsap.min.js"></script>
    <script src="./js/axios.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      // 现在浏览器支持ES6语法，自然包括import方式引入js文件
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
      const gui = new dat.GUI();
      var renderer, scene, camera, controls;
      // 初始化场景
      function initScene() {
        scene = new THREE.Scene();
        //给场景添加烟雾效果
        // 参数：烟雾颜色，烟雾范围near，烟雾范围far
        // scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x000000, 0, 3000);
        // 给场景添加坐标轴
        var axes = new THREE.AxesHelper(100);
        scene.add(axes);
      }
      // 初始化渲染器
      function initRenderer() {
        // antialias是否开启抗锯齿
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearAlpha(0.2);
        renderer.setSize(window.innerWidth, window.innerHeight);
        // renderer.setClearColor(0xeeeeee);
        renderer.physicallyCorrectLights = true;
        document.body.appendChild(renderer.domElement);
      }
      // 初始化相机
      let v = new THREE.Vector3(32.499207496643066, 38.21255111694336, 0);
      function initCamera() {
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        // camera.position.y = 0;
        camera.position.set(0, 0, 250);
        camera.lookAt(v);

        // camera.position.z = 220;
      }
      // 初始化控制器
      function initControls() {
        controls = new OrbitControls(camera, renderer.domElement);
        // controls.target.set(32.499207496643066, 38.21255111694336, 0);
        controls.target.set(0, 0, 0);
        // 阻尼效果
        controls.enableDamping = true;
        // 摄像机自动旋转
        controls.autoRotate = false;
        // 控制垂直角度的旋转范围
        // controls;
      }
      var pointLight;
      // 初始化光源
      function initLight() {
        // 白光，光强1
        // pointLight = new THREE.PointLight(0xffffff, 10000);
        // pointLight.position.set(0, 0, 80);
        // scene.add(pointLight);
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1);
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
        const directionalLight3 = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight2.position.set(0, -1, 0);
        directionalLight3.position.set(0, 0, 1);
        scene.add(directionalLight1);
        scene.add(directionalLight2);
        scene.add(directionalLight3);
      }
      var stats = new Stats();
      document.body.appendChild(stats.dom);

      function render() {
        onRay();
        renderer.render(scene, camera);
        controls.update();
        stats.update(); //更新性能插件
        requestAnimationFrame(render);
      }

      function onRay() {
        raycaster.setFromCamera(mouse, camera);
        const mapChildren = scene.children.filter(
          (item) => item.geometry === "ExtrudeGeometry"
        );
        // 被射线照射到的一组对象
        const intersects = raycaster.intersectObjects(mapChildren);
        // console.log(intersects);
        const tooltip = document.getElementById("tooltip");
        // 如果有相交的物体
        if (intersects.length > 0) {
          tooltip.style.display = "block";
          tooltip.style.left = mouseX + "px";
          tooltip.style.top = mouseY + "px";
          tooltip.innerText = intersects[0].object.name;
          if (INTERSECTED != intersects[0].object) {
            // 这里选中的物体是上一个选中物体。
            if (INTERSECTED) {
              // 把上一个选中的物体设置为当前色。
              INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
              // INTERSECTED.position.z = 0;
            }
            // 设置当前选中的物体
            INTERSECTED = intersects[0].object;
            // 保留当前选中物体，**原本的颜色**
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
            // console.log(INTERSECTED.currentHex);
            // 设置当前选中的物体颜色为红色
            INTERSECTED.material.color.setHex(0xff0000);
            // INTERSECTED.position.z = 3;
          }
          // 如果没有相交的物体，把选中的物体设置为原来的颜色
        } else {
          if (INTERSECTED) {
            INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            // INTERSECTED.position.z = 0;
          }
          // 清空选中物体
          tooltip.style.display = "none";

          INTERSECTED = null;
        }
      }
      window.addEventListener("click", click);
      function click() {
        raycaster.setFromCamera(mouse, camera);
        const mapChildren = scene.children.filter(
          (item) => item.type === "Mesh"
        );
        // 被射线照射到的一组对象
        const intersects = raycaster.intersectObjects(mapChildren);
        const tooltip = document.getElementById("tooltip");
        if (intersects.length > 0) {
          console.log(intersects[0]);
          upz = upz * 2;
          getprovinceJson(intersects[0].object);
        } else {
          console.log("没有选中");
          // getGeoJson(100000);
        }
      }
      function cube(meshArr) {
        meshArr.map((item) => {
          let geometry = new THREE.SphereGeometry(0.1, 32, 16);
          let material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
          let sphere = new THREE.Mesh(geometry, material);
          sphere.position.set(
            item.geometry.boundingSphere.center.x,
            item.geometry.boundingSphere.center.y,
            1
          );
          scene.add(sphere);
        });
      }

      // function cube(mesh) {
      //   let geometry = new THREE.SphereGeometry(1, 32, 16);
      //   let material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      //   let sphere = new THREE.Mesh(geometry, material);
      //   sphere.position.set(
      //     mesh.geometry.boundingSphere.center.x,
      //     mesh.geometry.boundingSphere.center.y,
      //     0
      //   );
      //   scene.add(sphere);
      // }

      // function cube() {
      //   let geometry = new THREE.SphereGeometry(1, 32, 16);
      //   let material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      //   let sphere = new THREE.Mesh(geometry, material);
      //   sphere.position.set(116.405285, 39.904989, 0);
      //   scene.add(sphere);
      // }
      // 用于计算整个图形的中心位置
      const mapSideInfo = {
        minlon: Infinity,
        maxlon: -Infinity,
        minlat: Infinity,
        maxlat: -Infinity,
      };

      // 中心坐标，用于到时候将图形绘制到坐标系原点计算使用
      let centerPos = {};
      let merTrans;
      var geoJson;
      var featuresArr, provinceJson;
      var meshArr = [],
        lineArr = [],
        mesh;
      var upz = 2;

      const getGeoJson = async (adcode, upz) => {
        axios({
          url: `https://geo.datav.aliyun.com/areas_v3/bound/geojson?code=${adcode}_full`,
          method: "get",
        })
          .then(function (response) {
            if (meshArr.length !== 0 && lineArr.length !== 0) {
              scene.remove(...meshArr);
              // scene.remove(
              //   meshArr[meshArr.findIndex((item) => item.adcode == adcode)]
              // );
              scene.remove(...lineArr);
              // meshArr.splice(
              //   meshArr.findIndex((item) => item.adcode == adcode),
              //   1
              // );
              console.log(meshArr);
            }
            geoJson = response.data;
            featuresArr = geoJson.features;
            // geoJson.features.pop();
            console.log(geoJson);
            calcSide(geoJson);
            meshArr = drawMap(geoJson);
            // mesh = drawMap(geoJson);
            // mesh.map((item) => {
            //   meshArr.push(item);
            // });
            lineArr = drawLine(geoJson);
            console.log(meshArr);
            console.log(lineArr);
            console.log(scene);
            // scene.add(...meshArr);
            scene.add(...meshArr);
            scene.add(...lineArr);
            // if (upz) {
            //   console.log(upz);
            //   meshArr.map((item) => {
            //     item.position.z += upz;
            //   });
            //   lineArr.map((item) => {
            //     item.position.z += upz;
            //   });
            //   upz += upz;
            // } else {
            //   upz -= upz;
            //   meshArr.map((item) => {
            //     item.position.z = 0;
            //   });
            //   lineArr.map((item) => {
            //     item.position.z = 0;
            //   });
            // }

            // meshArr[0].position.z += 2;
            // meshArr.map((item) => {
            //   item.geometry.computeBoundingSphere();
            // });
            // cube(meshArr);
          })
          .catch(function (err) {
            console.log(err);
          });
      };
      getGeoJson(100000);

      function getprovinceJson(item) {
        console.log(item.adcode);
        getGeoJson(item.adcode, upz);
      }
      var planewh = {
        width: 300,
        height: 300,
      };
      function createPlane() {
        var planeGeometry = new THREE.PlaneGeometry(
          planewh.width,
          planewh.height,
          1,
          1
        );
        const texture = new THREE.TextureLoader().load("./img/mapback.png");
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        // texture.repeat.set(1911, 750);
        var planeMaterial = new THREE.MeshLambertMaterial({
          // map: texture,
          color: 0xffffff,
        });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.z = -10;
        scene.add(plane);
      }

      //包装一个根据geoJson格式数据获取经纬度坐标集合的方法
      const dealWithCoord = (geometry, callback) => {
        const { type, coordinates } = geometry;

        // 多面处理
        if (type === "MultiPolygon") {
          coordinates.forEach((polyArray) => {
            polyArray.forEach((lonlatArr) => {
              callback(lonlatArr);
            });
          });
        } else
          coordinates.forEach((lonlatArr) => {
            callback(lonlatArr);
          });
      };

      //包装获取最大最小经纬度信息以及中心点坐标信息的方法，传递的参数就是获取到的geoJson数据
      const calcSide = (geoJson) => {
        const { features } = geoJson;

        features.forEach((feature) => {
          dealWithCoord(feature.geometry, (lonlatArr) => {
            lonlatArr.forEach(([lon, lat]) => {
              if (lon > mapSideInfo.maxlon) mapSideInfo.maxlon = lon;
              if (lon < mapSideInfo.minlon) mapSideInfo.minlon = lon;
              if (lat > mapSideInfo.maxlat) mapSideInfo.maxlat = lat;
              if (lat < mapSideInfo.minlat) mapSideInfo.minlat = lat;
            });
          });
        });

        centerPos = {
          x: (mapSideInfo.maxlon + mapSideInfo.minlon) / 2,
          y: (mapSideInfo.maxlat + mapSideInfo.minlat) / 2,
        };
        // 设置地图中点为北京
        // centerPos = {
        //   x: 116.41995,
        //   y: 40.18994,
        // };
        // console.log([centerPos.x, centerPos.y]);
        merTrans = d3
          .geoMercator()
          .center([centerPos.x, centerPos.y])
          .translate([0, 0]);
        // console.log(merTrans);
      };

      const drawPlan = (lonlatArr) => {
        // 可以理解为canvas的绘制形状，moveTo、lineTo
        const shap = new THREE.Shape();
        lonlatArr.forEach((lonlat, index) => {
          const [x, y] = merTrans(lonlat);
          if (!index) shap.moveTo(x, y);
          else shap.lineTo(x, y);
        });
        return shap;
      };
      const drawPoint = (lonlatArr) => {
        const pointsArray = new Array();
        lonlatArr.forEach((lonlat) => {
          const [x, y] = merTrans(lonlat);
          // 创建三维点
          pointsArray.push(new THREE.Vector3(x, -y, 0.2));
        });
        return pointsArray;
      };
      const addmesh = (lonlatArr) => {
        // console.log(lonlatArr);
        const shap = drawPlan(lonlatArr);
        // 几何体
        const geo = new THREE.ExtrudeGeometry(shap, extrudeSettings);
        geo.rotateX(Math.PI);
        // 材质
        const material = new THREE.MeshStandardMaterial({
          color: randomColor(),
          //   color: "#0000ff",
        });
        // material.backup = material.color.getHex();
        // 物体
        const mesh = new THREE.Mesh(geo, material);
        return mesh;
      };
      const addLine = (lonlatArr) => {
        const lineGeometry = new THREE.BufferGeometry();
        const pointsArray = drawPoint(lonlatArr);
        lineGeometry.setFromPoints(pointsArray);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: "#000000",
        });
        let line = new THREE.Line(lineGeometry, lineMaterial);
        return line;
      };
      const randomColor = () =>
        `rgb(${Math.floor(Math.random() * 255)},${Math.floor(
          Math.random() * 255
        )},${Math.floor(Math.random() * 255)})`;

      const extrudeSettings = {
        steps: 10, //用于沿着挤出样条的深度细分的点的数量，默认值为1。
        depth: 5, //挤出的形状的深度，默认值为1。
        bevelEnabled: true, //对挤出的形状应用是否斜角，默认值为true。
        bevelThickness: 0.2, //设置原始形状上斜角的厚度。默认值为0.2。
        bevelSize: 0.1, //斜角与原始形状轮廓之间的延伸距离
        bevelOffset: 0,
        bevelSegments: 3, //斜角的分段层数
        // depth: 10,
        // bevelEnabled: false,
        // steps: 1,
      };
      const drawMap = (geoJson) => {
        // console.log(geoJson);
        const meshArray = [];
        const { features } = geoJson;
        features.forEach((feature) => {
          dealWithCoord(feature.geometry, (lonlatArr) => {
            let mesh = addmesh(lonlatArr);
            mesh.name = feature.properties.name;
            mesh.adcode = feature.properties.adcode;
            meshArray.push(mesh);
          });
        });
        return meshArray;
      };
      const drawLine = (geoJson) => {
        const lineArray = [];
        const { features } = geoJson;
        features.forEach((feature) => {
          dealWithCoord(feature.geometry, (lonlatArr) => {
            let line = addLine(lonlatArr);
            // line.position.set(0, 9, 0);
            lineArray.push(line);
          });
        });
        return lineArray;
      };

      var mouse, mouseX, mouseY, raycaster, INTERSECTED;
      mouse = new THREE.Vector2();
      const getSelMap = () => {
        const mapChildren = scene.children;
        raycaster = new THREE.Raycaster();
        const sizes = {
          width: window.innerWidth,
          height: window.innerHeight,
        };
        mouse = new THREE.Vector2();
        window.addEventListener("mousemove", (_event) => {
          mouse.x = (_event.clientX / sizes.width) * 2 - 1;
          mouse.y = -(_event.clientY / sizes.height) * 2 + 1;
          mouseX = _event.clientX;
          mouseY = _event.clientY;
        });
      };

      function addGui() {
        gui
          .add(extrudeSettings, "steps")
          .min(2)
          .max(10)
          .step(1)
          .name("steps")
          .onFinishChange(getGeoJson);
        gui
          .add(extrudeSettings, "depth")
          .min(2)
          .max(16)
          .step(1)
          .name("depth")
          .onFinishChange(getGeoJson);
        // gui
        //   .add(pointLight, "intensity")
        //   .min(5000)
        //   .max(50000)
        //   .step(10)
        //   .name("intensity");
        //   .onFinishChange(getGeoJson);
        // gui
        //   .add(planewh, "width")
        //   .min(100)
        //   .max(1000)
        //   .step(1)
        //   .name("width")
        //   .onFinishChange(createPlane);
        // gui
        //   .add(planewh, "height")
        //   .min(100)
        //   .max(1000)
        //   .step(1)
        //   .name("height")
        //   .onFinishChange(createPlane);
      }

      function start() {
        initRenderer();
        initScene();
        initCamera();
        initControls();
        initLight();
        addGui();
        getSelMap();
        createPlane();
        // mousemove();
        render();
      }
      start();
    </script>
  </body>
</html>
