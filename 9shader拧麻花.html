<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>three.js app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script src="./dat.gui/build/dat.gui.min.js"></script>
    <script src="./stats.js/build/stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/gsap.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      // 现在浏览器支持ES6语法，自然包括import方式引入js文件
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      const gui = new dat.GUI();
      var renderer, scene, camera, controls;
      // 初始化场景
      function initScene() {
        scene = new THREE.Scene();
        //给场景添加烟雾效果
        // 参数：烟雾颜色，烟雾范围near，烟雾范围far
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.Fog(0x000000, 0, 3000);
        // 给场景添加坐标轴
        var axes = new THREE.AxesHelper(100);
        scene.add(axes);
      }
      // 初始化渲染器
      function initRenderer() {
        // antialias是否开启抗锯齿
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xeeeeee);
        document.body.appendChild(renderer.domElement);
      }
      // 初始化相机
      function initCamera() {
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.x = 50;
        camera.position.y = 50;
        camera.position.z = 50;
      }
      // 初始化控制器
      function initControls() {
        controls = new OrbitControls(camera, renderer.domElement);
        // 阻尼效果
        controls.enableDamping = true;
        // 摄像机自动旋转
        controls.autoRotate = false;
        // 控制垂直角度的旋转范围
        controls;
      }
      // 初始化光源
      function initLight() {
        // 白光，光强1
        var pointLight = new THREE.PointLight(0xffffff, 10000);
        pointLight.position.set(0, 100, 100);
        scene.add(pointLight);
      }
      var stats = new Stats();
      document.body.appendChild(stats.dom);
      const vertex = `
      mat4 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 rotate(vec3 v, vec3 axis, float angle) {
	mat4 m = rotationMatrix(axis, angle);
	return (m * vec4(v, 1.0)).xyz;
}



      uniform float uTime;
  varying vec2 vUv;
  const float PI = 3.1415925;
  void main() {
    
    vUv = uv;
    vec3 axis = vec3(1.0, 0.0, 0.0);
  float angle = position.x*sin(uTime);
  vec3 newPos = rotate(position, axis, angle);
  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);

  }
`;

      const fragment = `
      varying vec2 vUv;
  void main() {
    vec3 color1 = vec3(0.847, 0.204, 0.373);
  vec3 color2 = vec3(1.0);
  float mixer = step(0.5, fract(vUv.y * 3.0));
  // vec3 color = vec3(mixer);
  vec3 color = mix(color1, color2, mixer);
    gl_FragColor = vec4(color,1.0);
  }

`;
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
        },
        vertexShader: vertex,
        fragmentShader: fragment,
        // wireframe: true,
        // wireframe: true,
      });

      const geometry = new THREE.BoxGeometry(3, 1, 1, 64, 64, 64);
      //   const material = new THREE.MeshBasicMaterial({
      //     color: 0x0ca678,
      //     wireframe: true,
      //   });
      const mesh = new THREE.Mesh(geometry, material);

      const clock = new THREE.Clock();
      function render() {
        // 触底弹跳
        // circle.position.y = Math.abs(Math.sin(elapsedTime * 3));
        const time = clock.getElapsedTime();
        material.uniforms.uTime.value = time;
        // mesh.rotation.y = time;
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        controls.update();
        stats.update(); //更新性能插件
      }

      function start() {
        initRenderer();
        initScene();
        initCamera();
        initControls();
        initLight();
        render();
      }
      start();

      scene.add(mesh);
      console.log(mesh);
    </script>
  </body>
</html>
